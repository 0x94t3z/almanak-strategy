"""
Tests for my_strategy strategy.

Generated by: almanak strat new
Template: blank
"""

import json
import pytest
from pathlib import Path
from unittest.mock import MagicMock
from decimal import Decimal

from ..strategy import MyStrategyStrategy


@pytest.fixture
def config() -> dict:
    """Load test configuration from config.json."""
    config_path = Path(__file__).parent.parent / "config.json"
    if config_path.exists():
        with open(config_path) as f:
            return json.load(f)
    return {
        "strategy_id": "test-strategy-001",
        "chain": "base",
    }


@pytest.fixture
def strategy(config: dict) -> MyStrategyStrategy:
    """Create strategy instance for testing."""
    return MyStrategyStrategy(
        config=config,
        chain=config.get("chain", "base"),
        wallet_address="0x" + "1" * 40,
    )


@pytest.fixture
def mock_market() -> MagicMock:
    """Create a mock MarketSnapshot."""
    market = MagicMock()
    market.price.return_value = Decimal("2000")
    market.chain = "base"
    market.wallet_address = "0x" + "1" * 40

    # Mock balance
    balance_mock = MagicMock()
    balance_mock.balance = Decimal("100")
    balance_mock.balance_usd = Decimal("100000")
    market.balance.return_value = balance_mock

    # Mock RSI
    rsi_mock = MagicMock()
    rsi_mock.value = Decimal("50")
    market.rsi.return_value = rsi_mock

    return market


class TestMyStrategyStrategy:
    """Tests for MyStrategyStrategy strategy."""

    def test_initialization(self, strategy: MyStrategyStrategy) -> None:
        """Test strategy initialization."""
        assert strategy.chain == "base"
        assert strategy.wallet_address == "0x" + "1" * 40

    def test_decide_returns_intent(self, strategy: MyStrategyStrategy, mock_market: MagicMock) -> None:
        """Test that decide() returns an Intent."""
        result = strategy.decide(mock_market)

        # Should return some kind of Intent (swap or hold)
        assert result is None or hasattr(result, 'intent_type')

    def test_decide_handles_errors(self, strategy: MyStrategyStrategy, mock_market: MagicMock) -> None:
        """Test that decide() handles errors gracefully."""
        # Cause an error by making price() raise
        mock_market.price.side_effect = ValueError("Price unavailable")

        result = strategy.decide(mock_market)

        # Should return hold on error, not raise
        assert result is not None
        assert "Error" in str(result.reason) or "hold" in str(result).lower()

    def test_get_status(self, strategy: MyStrategyStrategy) -> None:
        """Test get_status returns expected fields."""
        status = strategy.get_status()

        assert "strategy" in status
        assert "chain" in status
